import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as s,f as e,g as n,o as l}from"./app-gu2odQzq.js";const d="/assets/gdt-item-CijWg_S1.png",h={};function r(p,i){return l(),t("div",null,[i[0]||(i[0]=s("h1",{id:"【raymond-os】chapter-3-protected-mode",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#【raymond-os】chapter-3-protected-mode"},[s("span",null,"【Raymond-OS】Chapter 3. Protected Mode")])],-1)),i[1]||(i[1]=s("p",null,"认识段描述符，开启保护模式",-1)),e(" more "),i[2]||(i[2]=n('<div class="hint-container info"><p class="hint-container-title">相关信息</p><p>出于向前兼容，系统启动后会运行在 16 位的实模式下，需要手动开始 32 位进入保护模式，此过程包含固定步骤，但 gdt 表的构建相对繁琐</p></div><h2 id="一、过程分析" tabindex="-1"><a class="header-anchor" href="#一、过程分析"><span>一、过程分析</span></a></h2><p>进入保护模式固定的几个步骤：</p><ol><li>开 A20 总线：实模式中地址线有 20 位，上古时代有些大哥会写地址回环的逻辑（地址对 20 位取模），冒然把地址线增加到 32 位会让有些历史逻辑报错，为了兼容就加了个开关，需要打开后才开启 32 位地址线</li><li>加载 GDT：在分页之前，分段地址管理就是最先进的手段，保护模式当年就是以一手分段管理问世，GDT 表就是分段内存管理的配套信息，必须有它</li><li>修改 CR0 标志位：就是修改标记位</li><li>刷新流水线：流水线是 CPU 的一种机制，相当于多指令同时执行，指令是分 16 位译码和 32 位译码的，我们现在需要切换模式了，要确保之前的 16 位指令不会再产生影响，所以需要刷新流水线，而“长跳”是可触发流水线刷新的一种方式。<br> 其中 1、3 和 4 部分代码相当于固定，他们的内容、背景无论你知道或不知道，代码都是一样的写法。第 2 部分加载 gdt 表则是本章的重点内容，gdt 表可以理解为一个数组，我们需要把数组的起始地址告诉操作系统，其中有几个 gdt 表项，即数组元素，是必需的，gdt 表项结构诡异，需要花些时间理解</li></ol><h2 id="二、核心内容" tabindex="-1"><a class="header-anchor" href="#二、核心内容"><span>二、核心内容</span></a></h2><h3 id="_2-1-段描述符结构详解" tabindex="-1"><a class="header-anchor" href="#_2-1-段描述符结构详解"><span>2.1 段描述符结构详解</span></a></h3><p>实模式下的寻址是段寄存器左移 4 位之后与指令地址相加后获取实际物理地址，看似分段但其实没有段信息的维护，无法进行有效管理，于是在保护模式下有了 GDT 表。所谓的 GDT 表，可以理解为一个段描述信息数组，其中的表项被称为段描述符，每个段描述符固定 64 位，之前段寄存器中的数据会被解析成数组索引，于是在保护模式下，寻址会先通过段寄存器信息获取到段描述符，从描述符中获取段基址，段基址结合指令地址获取到真实地址。<br><img src="'+d+`" alt="gdt-item" loading="lazy"><br> 短描述符结构如上，由于历史原因，其结构很混乱，段基址、段界限都需要自己拼（CPU 会有对应的缓存机制）。我们之后会开启分页，这里的分段模式只是一个必经的过渡阶段，以下是描述符各位的介绍</p><table><thead><tr><th>位数范围</th><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>63-56</td><td>Base Address 31:24</td><td>段基址的高 8 位</td></tr><tr><td>55</td><td>G (Granularity)</td><td>粒度位，0：字节为单位，1：4KB 为单位</td></tr><tr><td>54</td><td>D/B (Default/Big)</td><td>默认操作数大小，0：16 位，1：32 位</td></tr><tr><td>53</td><td>L (64-bit code segment)</td><td>64 位代码段标志，仅在 64 位模式下有效</td></tr><tr><td>52</td><td>AVL</td><td>系统软件可用位，通常未使用</td></tr><tr><td>51-48</td><td>Limit 19:16</td><td>段界限的高 4 位</td></tr><tr><td>47</td><td>P (Present)</td><td>段存在位，0：未存在，1：存在</td></tr><tr><td>46-45</td><td>DPL (Descriptor Privilege Level)</td><td>描述符特权级，0：最高，3：最低</td></tr><tr><td>44</td><td>S (Descriptor type)</td><td>描述符类型，0：系统段，1：代码或数据段</td></tr><tr><td>43-40</td><td>Type</td><td>段类型，对于代码段和数据段有不同的含义</td></tr><tr><td>39-32</td><td>Base Address 23:16</td><td>段基址的中 8 位</td></tr><tr><td>31-16</td><td>Base Address 15:0</td><td>段基址的低 16 位</td></tr><tr><td>15-0</td><td>Segment Limit 15:0</td><td>段界限的低 16 位</td></tr></tbody></table><h3 id="_2-2-构建-gdt-表" tabindex="-1"><a class="header-anchor" href="#_2-2-构建-gdt-表"><span>2.2 构建 GDT 表</span></a></h3><p>我们的构建 GDT 表，就是确定描述符，然后将数据写到固定位置。理论上段描述符是要配合分段机制来实现地址空间隔离，而实际上，通过段描述符的格式我们可以得知，段界限的 20 位配合粒度位，，我们也会将整个 2^20 * 4KB = 4GB 内存映射到一个段，而这就是所谓的平坦模型<br> 根据约定，GDT 第一个描述符为空以避免歧义，此外我们需要一个数据段、一个代码段，这两个是必须要有的，以及我们需要一个显卡段来映射显卡内存。所以接下来就是结合描述符各位的信息，拼出每个段描述符的内容</p><h4 id="_2-2-1-空描述符" tabindex="-1"><a class="header-anchor" href="#_2-2-1-空描述符"><span>2.2.1 空描述符</span></a></h4><p>空描述符只需各位都置零即可</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" data-title="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">GDT_BASE:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> dd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0x00000000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x00000000</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_2-2-2-代码段描述符" tabindex="-1"><a class="header-anchor" href="#_2-2-2-代码段描述符"><span>2.2.2 代码段描述符</span></a></h4><p>因为我们采用平坦模型，所以段基址无疑全是 0，段界限全是 1，结合之前的描述可知低 32 位是 0x0000FFFF，接下来从左向右我们细看高 32 位</p><table><thead><tr><th>描述</th><th>二进制表示</th></tr></thead><tbody><tr><td>8 位段基址写 0</td><td>b00000000</td></tr><tr><td>1 位 G 位颗粒度写 1</td><td>b000000001</td></tr><tr><td>1 位 D/B 位写 1 表示默认 16 位操作数</td><td>b0000000011</td></tr><tr><td>1 位 L 位写 0 不用管</td><td>b00000000110</td></tr><tr><td>1 位 AVL 位写 0 不用管</td><td>b000000001100</td></tr><tr><td>4 位段界限写 1</td><td>b0000000011001111</td></tr><tr><td>1 位 P 位存在位写 1</td><td>b00000000110011111</td></tr><tr><td>2 位 DPL 写 0，表最高级</td><td>b0000000011001111100</td></tr><tr><td>1 位 S 位写 1</td><td>b00000000110011111001</td></tr><tr><td>4 位 type 位写 1000</td><td>b000000001100111110011000</td></tr><tr><td>8 位段基址写 0</td><td>b00000000110011111001100000000000</td></tr></tbody></table><p>转成 16 进制就是 <code>0x00CF9800</code></p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" data-title="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CODE_DESC:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> dd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0x0000FFFF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x00CF9800</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_2-2-3-数据段描述符" tabindex="-1"><a class="header-anchor" href="#_2-2-3-数据段描述符"><span>2.2.3 数据段描述符</span></a></h4><p>低 32 位与代码段一致，高 32 位中，只有 type 位与代码段不一致，数据段的 4 位 type 位的值是 0010，所以最终数据段的高 32 位为：<code>b0000 0000 1100 1111 1001 0010 0000 0000</code>，十六进制为 <code>0x00CF9200</code></p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" data-title="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">DATA_STACK_DESC:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> dd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0x0000FFFF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x00CF9200</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_2-2-4-显存段描述符" tabindex="-1"><a class="header-anchor" href="#_2-2-4-显存段描述符"><span>2.2.4 显存段描述符</span></a></h4><p>因为我们只需要在显示器上输出文本，所有我们直接把显存段映射到实模式下文本模式显示适配器缓存的地址空间（参见第一章实模式下内存布局），其起始地址为 0xB8000，结束地址为 0xBFFFF，我们以 4KB 为粒度的话，可以得到描述符中段界限为 7，所以显存段的低 32 位为 <code>0x80000007</code>。<br> 而再次使用之前的方法，我们可以得到其高 32 位为 <code>00000000110000001001001000001011b</code>，即 <code>0x00C0920B</code></p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" data-title="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">VIDEO_DESC:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> dd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0x80000007</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x00C0920B</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="_2-2-5-gdt-表总览" tabindex="-1"><a class="header-anchor" href="#_2-2-5-gdt-表总览"><span>2.2.5 GDT 表总览</span></a></h4><p>构建 gdt 表听起来抽象，但是实际上就是我们刚刚写的 4 行代码，如下所示，其中 EMPTY_DESC、CODE_DESC等 tag 会在机器码生成后被消除，dd 是汇编定义双字的指令，所以下面四行代码其实是表示了 64b*4 的一块内存空间，这就是我们的 gdt 表，而且 EMPTY_DESC这第一个 tag 就可以拿到我们 gdt 这块内存空间的起始地址</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" data-title="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">; 这里其实就是GDT的起始地址，第一个描述符为空</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">EMPTY_DESC:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> dd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0x00000000</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x00000000</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">; 代码段描述符，一个dd为4字节，段描述符为8字节，先定义低32位，再定义高32位</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">CODE_DESC:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> dd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0x0000FFFF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x00CF9800</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">; 栈段描述符，和数据段共用</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">DATA_STACK_DESC:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> dd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0x0000FFFF</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x00CF9200</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">; 显卡段，非平坦</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">VIDEO_DESC:</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> dd</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0x80000007</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x00C0920B</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-3-加载-gdt-表" tabindex="-1"><a class="header-anchor" href="#_2-3-加载-gdt-表"><span>2.3 加载 GDT 表</span></a></h3><p>加载 GDT 表需要使用 lgdt命令，它需要GDT_BASE 和 GDT_LIMIT 信息：</p><ul><li>GDT_BASE 是 GDT 在内存中的起始地址。</li><li>GDT_LIMIT 是 GDT 的大小减去 1，表示 GDT 的限制（类比数组偏移）。</li></ul><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" data-title="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">GDT_SIZE </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">equ</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> $ - GDT_BASE</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">GDT_LIMIT </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">equ</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> GDT_SIZE - </span><span style="--shiki-light:#986801;--shiki-dark:#C678DD;">1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">gdt_ptr </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">dw</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> GDT_LIMIT</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">        dd</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> GDT_BASE</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-4-构建段选择子" tabindex="-1"><a class="header-anchor" href="#_2-4-构建段选择子"><span>2.4 构建段选择子</span></a></h3><p>在实模式中，段寄存器值左移四位后与指令、数据地址相加便得到真实地址，而在保护模式中，段寄存器中记录的主要是段描述符的偏移量，而段寄存器中的数据也有了新的名字叫段选择子，段选择子包括偏移量、TI 和 RPL，其中 TI 为 1 表示此为 LDT，为 0 则表示 GDT；RPL 表示特权级，值 0 为最高级，值 3 为最低级</p><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">15</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">      3</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  2</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  1</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  0</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">+--------+--+--+--+</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">| </span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">Index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">  |</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">TI</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">RPL</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|</span></span>
<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">+--------+--+--+--+</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>于是，我们的三个描述符对应的选择子分别为：</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" data-title="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SELECTOR_CODE </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">equ</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  0000000000001000b</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SELECTOR_DATA </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">equ</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">  0000000000010000b</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SELECTOR_VIDEO </span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">equ</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0000000000011000b</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-5-开启保护模式" tabindex="-1"><a class="header-anchor" href="#_2-5-开启保护模式"><span>2.5 开启保护模式</span></a></h3><p>经过上述前提铺垫后，进入保护模式的代码简单如下。其中需要注意的是，CPU 的流水线工作模型导致我们在进入保护模式时还有部分实模式的 16 位指令在进行中，为了避免产生预期之外的情况，我们需要刷新流水线，而刷新流水线的方式可使用长跳，即代码中 jmp dword SELECTOR_CODE:p_mode_start，其中 p_mode_start其实就是我们在保护模式运行的一段测试代码</p><div class="language-asm line-numbers-mode" data-highlighter="shiki" data-ext="asm" data-title="asm" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">loader_start:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> </span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    ; 打开A20地址线</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">    in</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> al</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x92</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">    or</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> al</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">00000010B</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">    out</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 0x92</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">al</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    ; 加载gdt</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">    lgdt</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> [gdt_ptr]</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    ; cr0第0位置1</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">    mov</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> eax</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">cr0</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">    or</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> eax</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">0x00000001</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">    mov</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> cr0</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">eax</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    ; 刷新流水线</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#C678DD;">    jmp</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> dword</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> SELECTOR_CODE:</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">p_mode_start</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,39))])}const g=a(h,[["render",r],["__file","os-cp3.html.vue"]]),o=JSON.parse('{"path":"/posts/rd/os/os-cp3.html","title":"【Raymond-OS】Chapter 3. Protected Mode","lang":"zh-CN","frontmatter":{"icon":"pen-to-square","date":"2025-01-21T00:00:00.000Z","category":["操作系统"],"tag":["主线"],"description":"认识段描述符，开启保护模式","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/posts/rd/os/os-cp3.html"}],["meta",{"property":"og:site_name","content":"山与长生"}],["meta",{"property":"og:title","content":"【Raymond-OS】Chapter 3. Protected Mode"}],["meta",{"property":"og:description","content":"认识段描述符，开启保护模式"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-01-21T13:49:16.000Z"}],["meta",{"property":"article:tag","content":"主线"}],["meta",{"property":"article:published_time","content":"2025-01-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-01-21T13:49:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"【Raymond-OS】Chapter 3. Protected Mode\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2025-01-21T00:00:00.000Z\\",\\"dateModified\\":\\"2025-01-21T13:49:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Raymond\\",\\"url\\":\\"https://avatars.githubusercontent.com/theflyingraymond\\"}]}"]]},"headers":[{"level":2,"title":"一、过程分析","slug":"一、过程分析","link":"#一、过程分析","children":[]},{"level":2,"title":"二、核心内容","slug":"二、核心内容","link":"#二、核心内容","children":[{"level":3,"title":"2.1 段描述符结构详解","slug":"_2-1-段描述符结构详解","link":"#_2-1-段描述符结构详解","children":[]},{"level":3,"title":"2.2 构建 GDT 表","slug":"_2-2-构建-gdt-表","link":"#_2-2-构建-gdt-表","children":[]},{"level":3,"title":"2.3 加载 GDT 表","slug":"_2-3-加载-gdt-表","link":"#_2-3-加载-gdt-表","children":[]},{"level":3,"title":"2.4 构建段选择子","slug":"_2-4-构建段选择子","link":"#_2-4-构建段选择子","children":[]},{"level":3,"title":"2.5 开启保护模式","slug":"_2-5-开启保护模式","link":"#_2-5-开启保护模式","children":[]}]}],"git":{"createdTime":1737467356000,"updatedTime":1737467356000,"contributors":[{"name":"Raymond","username":"Raymond","email":"suncheng11@meituan.com","commits":1,"url":"https://github.com/Raymond"}]},"readingTime":{"minutes":7.45,"words":2234},"filePathRelative":"posts/rd/os/os-cp3.md","localizedDate":"2025年1月21日","excerpt":"\\n<p>认识段描述符，开启保护模式</p>\\n","autoDesc":true}');export{g as comp,o as data};
